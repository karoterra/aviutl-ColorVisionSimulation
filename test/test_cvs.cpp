#include <gtest/gtest.h>

#include <algorithm>
#include <filesystem>
#include <format>
#include <fstream>
#include <iostream>
#include <string>
#include <vector>

#define STB_IMAGE_IMPLEMENTATION
#define STB_IMAGE_WRITE_IMPLEMENTATION
#include <stb_image.h>
#include <stb_image_write.h>

#include "cl_manager.h"
#include "color.h"
#include "cvs_cl.h"
#include "cvs_cpu.h"
#include "cvs_params.h"

/*
  Reference images are generated by DaltonLens-Python.
  https://github.com/DaltonLens/DaltonLens-Python
*/

namespace fs = std::filesystem;

const fs::path kImageSourcePath = "test/images";
const fs::path kImageDestPath = "test_out";

template <typename T>
T abs_diff(const T a, const T b) {
  if (a < b) return b - a;
  return a - b;
}

struct Image {
  int width;
  int height;
  std::vector<cvs::BGRA> pixels;

  Image(int w, int h) : width(w), height(h), pixels(w * h) {}

  Image(const Image& image)
      : width(image.width),
        height(image.height),
        pixels(image.pixels.begin(), image.pixels.end()) {}

  static Image Diff(const Image& a, const Image& b) {
    Image im_diff(a.width, a.height);
    for (size_t i = 0; i < a.pixels.size(); i++) {
      auto px_a = a.pixels[i];
      auto px_b = b.pixels[i];
      auto px = cvs::BGRA{
          abs_diff(px_a.b, px_b.b),
          abs_diff(px_a.g, px_b.g),
          abs_diff(px_a.r, px_b.r),
          255,
      };
      im_diff.pixels[i] = px;
    }
    return im_diff;
  }

  cvs::BGRA MaxValue() const {
    cvs::BGRA max_val{0, 0, 0, 0};
    for (const auto px : pixels) {
      max_val = cvs::BGRA{
          std::max(px.b, max_val.b),
          std::max(px.g, max_val.g),
          std::max(px.r, max_val.r),
          std::max(px.a, max_val.a),
      };
    }
    return max_val;
  }
};

Image load_image(const fs::path& p) {
  Image im(0, 0);
  int comp;
  auto raw = stbi_load(p.string().c_str(), &im.width, &im.height, &comp, 4);
  if (!raw) return im;

  im.pixels.resize(im.width * im.height);
  for (size_t i = 0; i < im.pixels.size(); i++) {
    im.pixels[i] = cvs::BGRA{
        raw[i * 4 + 2],
        raw[i * 4 + 1],
        raw[i * 4 + 0],
        raw[i * 4 + 3],
    };
  }
  stbi_image_free(raw);
  return im;
}

void write_image(const fs::path& p, const Image& im) {
  std::vector<stbi_uc> raw(im.width * im.height * 4);
  for (size_t i = 0; i < im.pixels.size(); i++) {
    raw[i * 4 + 0] = im.pixels[i].r;
    raw[i * 4 + 1] = im.pixels[i].g;
    raw[i * 4 + 2] = im.pixels[i].b;
    raw[i * 4 + 3] = im.pixels[i].a;
  }
  stbi_write_png(p.string().c_str(), im.width, im.height, 4, raw.data(), 0);
}

struct SimulationTestParam {
  cvs::ColorVisionType type;
  float severity;
  std::string param_str;
};

std::ostream& operator<<(std::ostream& stream, const SimulationTestParam& p) {
  return stream << p.param_str;
}

const auto kSimulationTestParams = std::vector<SimulationTestParam>{
    {cvs::ColorVisionType::Protan, 1.f, "protan_1.0"},
    {cvs::ColorVisionType::Protan, 0.55f, "protan_0.55"},
    {cvs::ColorVisionType::Deutan, 1.f, "deutan_1.0"},
    {cvs::ColorVisionType::Deutan, 0.55f, "deutan_0.55"},
    {cvs::ColorVisionType::Tritan, 1.f, "tritan_1.0"},
    {cvs::ColorVisionType::Tritan, 0.55f, "tritan_0.55"},
};

class SimulationTest : public testing::TestWithParam<SimulationTestParam> {};
INSTANTIATE_TEST_CASE_P(CVS, SimulationTest,
                        testing::ValuesIn(kSimulationTestParams));

TEST_P(SimulationTest, Brettel1997CL) {
  SimulationTestParam param = GetParam();

  EXPECT_TRUE(cvs::CLManager::GetInstance().IsAvailable());

  const auto image_name = std::format("brettel1997_{}.png", param.param_str);
  EXPECT_TRUE(fs::exists(kImageSourcePath / "input.png"));
  EXPECT_TRUE(fs::exists(kImageSourcePath / image_name));

  auto image = load_image(kImageSourcePath / "input.png");
  const auto image_ref = load_image(kImageSourcePath / image_name);
  const auto image_out_dir = kImageDestPath / "Brettel1997CL";
  fs::create_directories(image_out_dir);

  cvs::SimulateBrettel1997CL(param.type, param.severity, image.pixels.data(),
                             image.pixels.size());
  const auto image_diff = Image::Diff(image, image_ref);
  const auto max_val = image_diff.MaxValue();

  write_image(image_out_dir / image_name, image);
  write_image(image_out_dir / ("diff_" + image_name), image_diff);

  EXPECT_LT(max_val.b, 10);
  EXPECT_LT(max_val.g, 10);
  EXPECT_LT(max_val.r, 10);
}

TEST_P(SimulationTest, Vienot1999CL) {
  SimulationTestParam param = GetParam();

  EXPECT_TRUE(cvs::CLManager::GetInstance().IsAvailable());

  const auto image_name = std::format("vienot1999_{}.png", param.param_str);
  EXPECT_TRUE(fs::exists(kImageSourcePath / "input.png"));
  EXPECT_TRUE(fs::exists(kImageSourcePath / image_name));

  auto image = load_image(kImageSourcePath / "input.png");
  const auto image_ref = load_image(kImageSourcePath / image_name);
  const auto image_out_dir = kImageDestPath / "Vienot1999CL";
  fs::create_directories(image_out_dir);

  cvs::SimulateVienot1999CL(param.type, param.severity, image.pixels.data(),
                            image.pixels.size());
  const auto image_diff = Image::Diff(image, image_ref);
  const auto max_val = image_diff.MaxValue();

  write_image(image_out_dir / image_name, image);
  write_image(image_out_dir / ("diff_" + image_name), image_diff);

  EXPECT_LT(max_val.b, 10);
  EXPECT_LT(max_val.g, 10);
  EXPECT_LT(max_val.r, 10);
}

TEST_P(SimulationTest, Brettel1997CPU) {
  SimulationTestParam param = GetParam();

  const auto image_name = std::format("brettel1997_{}.png", param.param_str);
  EXPECT_TRUE(fs::exists(kImageSourcePath / "input.png"));
  EXPECT_TRUE(fs::exists(kImageSourcePath / image_name));

  auto image = load_image(kImageSourcePath / "input.png");
  const auto image_ref = load_image(kImageSourcePath / image_name);
  const auto image_out_dir = kImageDestPath / "Brettel1997CPU";
  fs::create_directories(image_out_dir);

  cvs::SimulateBrettel1997CPU(param.type, param.severity, image.pixels.data(),
                              image.pixels.size());
  const auto image_diff = Image::Diff(image, image_ref);
  const auto max_val = image_diff.MaxValue();

  write_image(image_out_dir / image_name, image);
  write_image(image_out_dir / ("diff_" + image_name), image_diff);

  EXPECT_LT(max_val.b, 10);
  EXPECT_LT(max_val.g, 10);
  EXPECT_LT(max_val.r, 10);
}

TEST_P(SimulationTest, Vienot1999CPU) {
  SimulationTestParam param = GetParam();

  const auto image_name = std::format("vienot1999_{}.png", param.param_str);
  EXPECT_TRUE(fs::exists(kImageSourcePath / "input.png"));
  EXPECT_TRUE(fs::exists(kImageSourcePath / image_name));

  auto image = load_image(kImageSourcePath / "input.png");
  const auto image_ref = load_image(kImageSourcePath / image_name);
  const auto image_out_dir = kImageDestPath / "Vienot1999CPU";
  fs::create_directories(image_out_dir);

  cvs::SimulateVienot1999CPU(param.type, param.severity, image.pixels.data(),
                             image.pixels.size());
  const auto image_diff = Image::Diff(image, image_ref);
  const auto max_val = image_diff.MaxValue();

  write_image(image_out_dir / image_name, image);
  write_image(image_out_dir / ("diff_" + image_name), image_diff);

  EXPECT_LT(max_val.b, 10);
  EXPECT_LT(max_val.g, 10);
  EXPECT_LT(max_val.r, 10);
}
